use fixedbitset::FixedBitSet;

use super::{Technology, ALL_TECHNOLOGIES};

/// Returns the index of the technology in the list of all technoligies.
/// This is a constant value and will never change, unless the game version
/// changes.
///
/// This makes it suitable as the number of a bit in a bit set to store a
/// player's technologies.
fn get_technology_idx(technology: &'static Technology) -> usize {
    // SAFETY: We know that ALL_TECHNOLOGIES contains all possible technologies.
    unsafe {
        ALL_TECHNOLOGIES
            .iter()
            .enumerate()
            .find_map(
                |(idx, tech)| {
                    if *tech == technology {
                        Some(idx)
                    } else {
                        None
                    }
                },
            )
            .unwrap_unchecked()
    }
}

/// Returns the technology for a corresponding index acquired via
/// [`get_technology_idx`].
///
/// This will never fail if the index was generated by the same game version and
/// the value is constant.
fn get_technology_by_idx(idx: usize) -> &'static Technology {
    // SAFETY: idx has to be smaller than
    unsafe { ALL_TECHNOLOGIES.get_unchecked(idx) }
}

/// A struct that holds the information on which technologies a player has
/// acquired so far.
pub struct Technologies(FixedBitSet);

impl Technologies {
    #[must_use]
    pub fn new() -> Self {
        Self(FixedBitSet::with_capacity(ALL_TECHNOLOGIES.len()))
    }

    pub fn from_blocks<I: IntoIterator<Item = u32>>(blocks: I) -> Self {
        Self(FixedBitSet::with_capacity_and_blocks(
            ALL_TECHNOLOGIES.len(),
            blocks,
        ))
    }

    #[must_use]
    pub fn has_researched(&self, technology: &'static Technology) -> bool {
        self.0.contains(get_technology_idx(technology))
    }

    pub fn set_researched(&mut self, technology: &'static Technology) {
        self.0.set(get_technology_idx(technology), true);
    }

    #[must_use]
    pub fn as_blocks(&self) -> &[u32] {
        self.0.as_slice()
    }
}

impl Default for Technologies {
    fn default() -> Self {
        Self::new()
    }
}

#[test]
fn test_technologies() {
    use super::ALPHABET;

    let mut techs = Technologies::new();
    assert!(!techs.has_researched(&ALPHABET));
    techs.set_researched(&ALPHABET);
    assert!(techs.has_researched(&ALPHABET));
    let blocks = techs.as_blocks();

    let other_techs = Technologies::from_blocks(blocks.iter().copied());
    assert!(other_techs.has_researched(&ALPHABET));

    assert!(std::mem::size_of::<Technologies>() <= ALL_TECHNOLOGIES.len());
}
